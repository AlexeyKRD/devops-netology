# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

---
### 1. Какой системный вызов делает команда cd? 
> `strace /bin/bash -c 'cd /tmp' 2>&1 | grep tmp`  
> `chdir("/tmp") = 0`  
### 2. Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
> `strace file -c '/dev/tty' 2>&1 | grep open`  
> `/etc/magic.mgc` - (No such file or directory)  
> `/etc/magic` - файл есть, но на БД это не похоже))  
> `/usr/share/misc/magic.mgc` - но это ссылка на `/lib/file/magic.mgc`    
> `/lib/file/magic.mgc` - вот БД  
### 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
> `vagrant@vagrant:~$ ping 8.8.8.8 >> ping.log`  
> `vagrant@vagrant:~$ rm ping.log`  
> `vagrant@vagrant:~$ sudo lsof | grep deleted`  
> `ping      7004                        vagrant    1w      REG              253,0    20047    1311527 /home/vagrant/ping.log (deleted)`    
> `vagrant@vagrant:~$ echo "" | sudo tee /proc/7004/fd/1`  
### 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
> Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
### 5. В iovisor BCC есть утилита opensnoop:
### `root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop`
### `/usr/sbin/opensnoop-bpfcc`
### На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04
> `vagrant@vagrant:~$ sudo opensnoop-bpfcc`  
> `PID    COMM               FD ERR PATH`  
> `1216   vminfo              6   0 /var/run/utmp`  
> `601    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services`  
> `601    dbus-daemon        19   0 /usr/share/dbus-1/system-services`  
> `601    dbus-daemon        -1   2 /lib/dbus-1/system-services`  
> `601    dbus-daemon        19   0 /var/lib/snapd/dbus-1/system-services/`  
### 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
> uname - получить имя и информацию о текущем ядре,  системный вызов `uname()`   
> Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.  
### 7. Чем отличается последовательность команд через ; и через && в bash? Есть ли смысл использовать в bash &&, если применить set -e?
> `;` - последовательно выполнение команд, вне зависимости выполнилась первая команда либо нет.  
> `&&` - будет выполнять вторую команду только в том случае, если состояние выхода первой команды равно «0» — программа выполнена успешно.  
> Так как `-е` немедленный выход при выполнении команды с ненулевым результатом, использование `&&` есть, т.к. если будет нулевой результат выполнения команды до `&&`, то выполнение продолжится.  
### 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
> `-e` Скрипт немедленно завершит работу, если любая команда выйдет с ошибкой.     
> `-u` Благодаря ему оболочка проверяет инициализацию переменных в скрипте. Если переменной не будет, скрипт немедленно завершиться.  
> `-x` Очень полезен при отладке. С помощью него bash печатает в стандартный вывод все команды перед их исполнением.  
> `-o` Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать -o pipefail  
> При работе с bash будет хорошим тоном начинать каждый сценарий с `set -euxo pipefail`, ибо выведет необходимую информацию что не так)
### 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
> наиболее часто встречающийся статус `S`  
> `S` - interruptible sleep (waiting for an event to complete)  
> Дополнительные символы:  
> `<`    high-priority (not nice to other users)  
> `N`    low-priority (nice to other users)  
> `L`    has pages locked into memory (for real-time and custom IO)  
> `s`    is a session leader  
> `l`    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)  
> `+`    is in the foreground process group  